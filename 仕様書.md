# Random Trip Planner 仕様書

## 1. アプリ概要

### 1.1. アプリ名

Random Trip Planner

### 1.2. 目的

ユーザーが気軽に「ちょっと出かけたい」と思った時に、近場の穴場スポットと簡単なプランをランダムで提案する。

### 1.3. 対象ユーザー

18歳以上の全年齢、男女問わず。

## 2. 機能

### 2.1. メイン機能

*   **スポット提案**: ユーザーの入力に基づき、近場の穴場スポットとプランを提案する。ユーザーには3つプランを提案する。

### 2.2. 入力項目

*   **時間**:
    *   入力形式: 選択式と入力の両方
        *   選択肢: 3時間以内、半日、終日など
        *   入力: 自由入力 (分)
    *   備考: 自由入力の場合、「時間（分）」というラベルのテキストボックスを表示する
*   **移動手段**:
    *   選択肢: 徒歩、自転車、電車、バス、車
    *   バリデーション: 必須ではない (デフォルト値を設定)
*   **過ごし方**:
    *   選択肢: のんびり、アクティブ、癒しなど
    *   入力形式: 選択式

### 2.3. 出力

*   **スポット情報**:
    *   名称
    *   場所
    *   簡単な説明
    *   写真
*   **プラン**:
    *   各スポットでの所要時間
    *   移動時間
    *   具体的な移動手段 (例: ○○駅から徒歩5分)
    *   合計時間
    *   合計費用 (オプション)

## 3. UI/UX

### 3.1. 基本デザイン

*   スマホユーザーを対象としたシンプルなデザイン
*   片手で操作しやすいUI
*   直感的な操作性

### 3.2. 画面構成

1.  **トップ画面**:
    *   アプリの説明
    *   「プランを作成」ボタン
2.  **入力画面**:
    *   時間などを入力するフォーム
    *   「プランを提案」ボタン
3.  **提案画面**:
    *   スポット情報とプランを表示
    *   「別のプランを提案」ボタン: フォームの内容を再度送信し、新しいプランを提案する
    *   「地図で見る」ボタン: Google Mapでスポットを表示する

## 4. ロジック

### 4.1. スポット選定

1.  ユーザーの入力に基づき、AI API（Google Gemini）にリクエストを送信
2.  APIからスポット情報とプランを取得
3.  取得した情報を整形して表示

### 4.2. AI API

*   Google Gemini APIを利用
*   APIの利用方法、料金などを調査

## 5. 技術スタック

### 5.1. フロントエンド

*   言語: TypeScript
*   ライブラリ: React, react-hook-form, zod
*   フレームワーク: Next.js
*   CSS: Tailwind CSS
*   コンポーネントカタログ: Storybook

### 5.2. バックエンド

*   言語: TypeScript (Next.js APIルート)
*   サーバー: Next.js APIルート
*   データベース: PostgreSQL (docker compose)

### 5.3. テスト戦略

#### 5.3.1. テストの種類と目的

1. **ユニットテスト**
   - Jest: ロジックの単体テスト
   - React Testing Library: UIコンポーネントのテスト
   - カバレッジ目標: 80%以上

2. **統合テスト**
   - コンポーネント間の連携テスト
   - APIとの連携テスト
   - エラーハンドリングの検証

3. **E2Eテスト**
   - Playwright: ブラウザ自動化テスト
   - 主要ユーザーフローの検証
   - クロスブラウザテスト

#### 5.3.2. テスト設計方針

- テストファーストの開発を推奨
- テストケースは仕様書から導出
- エッジケースの網羅的なテスト
- パフォーマンステストの実施

#### 5.3.3. CI/CD

- GitHub Actionsでの自動化
- プルリクエスト時の自動テスト
- テストカバレッジレポート
- デプロイ前の品質チェック

### 5.4. アクセシビリティ

#### 5.4.1. 基本方針

- WCAG 2.1レベルAAに準拠
- スクリーンリーダー対応
- キーボード操作の最適化

#### 5.4.2. 実装指針

1. **マークアップ**
   - セマンティックHTML
   - 適切な見出し構造
   - WAI-ARIA属性の活用

2. **インタラクション**
   - キーボードナビゲーション
   - フォーカス管理
   - タッチターゲットサイズ

3. **視覚的な考慮**
   - カラーコントラスト比
   - テキストサイズの調整
   - アニメーションの制御

#### 5.4.3. テスト方法

- axe-coreによる自動チェック
- スクリーンリーダーでの動作確認
- キーボード操作の検証

### 5.5. 品質管理

#### 5.5.1. パフォーマンス最適化

1. **測定指標**
   - Core Web Vitals
   - Lighthouse スコア
   - ページロード時間

2. **最適化戦略**
   - 画像の最適化
   - コードの分割
   - キャッシュの活用

3. **モニタリング**
   - パフォーマンスメトリクスの収集
   - ボトルネックの特定
   - 継続的な改善

#### 5.5.2. エラーハンドリング

1. **エラー種別**
   - ネットワークエラー
   - APIエラー
   - バリデーションエラー

2. **対応方針**
   - ユーザーフレンドリーなエラーメッセージ
   - リトライ機能の実装
   - エラーログの収集

## 6. 開発体制

*   開発者: 1名

## 7. スケジュール

*   仕様作成: 1日
*   開発: 5日
*   テスト: 2日
*   デプロイ: 1日

## 8. 開発ガイドライン

### 8.1 コーディング規約

- TypeScriptの型安全性を最大限活用
- ESLintとPrettierによるコード整形
- コンポーネントはAtomic Designに基づいて設計
- 関数型プログラミングの原則に従う

### 8.2 ドキュメント

- コンポーネントはStorybookでドキュメント化
- READMEには環境構築手順を詳細に記載
- APIの仕様はSwaggerで管理
- 変更履歴はCHANGELOGで管理

### 8.3 パフォーマンス

- バンドルサイズの最適化
- 画像の最適化
- レンダリングパフォーマンスの改善
- メモリリークの防止

## 9. その他

*   gitでバージョン管理を行う
*   Atomic Designに基づいてコンポーネント設計を行う
*   リーダブルコードのようなベストプラクティスを参考にコードを記述する
*   テストコード内のコメントやテストの説明も日本語で記述する
*   各ライブラリの使い方やインストール方法などは、常に公式ドキュメントを参照して最新の状態に保つ
*   パッケージ管理ツールはyarnを使用する
